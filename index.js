// Generated by CoffeeScript 1.9.3
(function() {
  var NinjaStar, async, child_process, fs, fsmonitor, glob, minimatch, ninjaBulidGen, path, replacePath,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  async = require('async');

  child_process = require('child_process');

  fs = require('fs');

  fsmonitor = require('fsmonitor');

  glob = require('glob');

  minimatch = require('minimatch');

  ninjaBulidGen = require('ninja-build-gen');

  path = require('path');

  require('coffee-script/register');

  replacePath = function(filepath, replaceExt, dest) {
    var base, ext;
    ext = path.extname(filepath);
    if (replaceExt) {
      base = path.basename(filepath, ext) + replaceExt;
    } else {
      base = path.basename(filepath);
    }
    return path.join(dest, base);
  };

  NinjaStar = (function() {
    function NinjaStar() {
      this.generateNinja = bind(this.generateNinja, this);
      this.aggregate = bind(this.aggregate, this);
      this.single = bind(this.single, this);
      this.mem_matcher = bind(this.mem_matcher, this);
      this.ninja = null;
      this.memoryTargets = [];
      this.rules = {};
      this.buildLines = [];
      this.watchDir = '.';
      this.loadfile = null;
    }

    NinjaStar.prototype.loadFromFile = function(filepath) {
      var filepath2, o;
      filepath2 = path.resolve(filepath);
      o = require(filepath2);
      this.loadfile = filepath2;
      this.applyRules(o.rules);
      this.applyBuildLines(o.buildlines);
      this.watchDir = o.watchDir;
      return delete require.cache[filepath2];
    };

    NinjaStar.prototype.applyRules = function(rules) {
      var k, results1, v;
      this.rules = {};
      results1 = [];
      for (k in rules) {
        if (!hasProp.call(rules, k)) continue;
        v = rules[k];
        results1.push(this.rules[k] = v);
      }
      return results1;
    };

    NinjaStar.prototype.applyBuildLines = function(bls) {
      return this.buildLines = [].concat(bls);
    };

    NinjaStar.prototype.doNinja = function(callback) {
      var child;
      child = child_process.spawn('ninja');
      child.stderr.on('data', function(chunk) {
        return process.stderr.write(chunk);
      });
      child.stdout.on('data', function(chunk) {
        return process.stdout.write(chunk);
      });
      return child.on('close', function(code) {
        return callback();
      });
    };

    NinjaStar.prototype.autobuild = function() {
      var doNinja2;
      doNinja2 = (function(_this) {
        return function() {
          return _this.doNinja(function() {
            return null;
          });
        };
      })(this);
      fs.watch(this.loadfile, (function(_this) {
        return function(event, filename) {
          _this.loadFromFile(_this.loadfile);
          return _this.generateNinja(doNinja2);
        };
      })(this));
      return fsmonitor.watch(this.watchDir, null, (function(_this) {
        return function(changes) {
          return _this.generateNinja(doNinja2);
        };
      })(this));
    };

    NinjaStar.prototype.mem = function(filepath) {
      if (indexOf.call(this.memoryTargets, filepath) < 0) {
        return this.memoryTargets.push(filepath);
      }
    };

    NinjaStar.prototype.mem_matcher = function(pattern) {
      var f;
      return (function() {
        var i, len, ref, results1;
        ref = this.memoryTargets;
        results1 = [];
        for (i = 0, len = ref.length; i < len; i++) {
          f = ref[i];
          if (minimatch(f, pattern)) {
            results1.push(f);
          }
        }
        return results1;
      }).call(this);
    };

    NinjaStar.prototype.register = function(filepaths, using, dest) {
      var filepath, i, len;
      this.ninja.edge(dest).from(filepaths).using(using);
      for (i = 0, len = filepaths.length; i < len; i++) {
        filepath = filepaths[i];
        this.mem(filepath);
      }
      return this.mem(dest);
    };

    NinjaStar.prototype.registerAggregate = function(filepaths, using, dest) {
      return this.register(filepaths, using, dest);
    };

    NinjaStar.prototype.registerSingle = function(filepath, using, dest) {
      var newPath, rule;
      rule = this.rules[using];
      if (!rule) {
        console.log('cannot load rule: ' + using);
        return;
      }
      newPath = replacePath(filepath, rule.to_ext, dest);
      return this.register([filepath], using, newPath);
    };

    NinjaStar.prototype.findTargetsSingle = function(pattern, callback) {
      return glob(pattern, {}, (function(_this) {
        return function(err, globhitfiles) {
          var targetFiles;
          targetFiles = globhitfiles.concat(_this.mem_matcher(pattern));
          return callback(err, targetFiles);
        };
      })(this));
    };

    NinjaStar.prototype.findTargets = function(patterns, callback) {
      var d, x;
      if (typeof patterns === 'string') {
        return this.findTargetsSingle(patterns, callback);
      } else {
        d = [];
        x = patterns.map((function(_this) {
          return function(pattern) {
            return function(cb) {
              return _this.findTargetsSingle(pattern, function(err, targetFiles) {
                var f, i, len;
                for (i = 0, len = targetFiles.length; i < len; i++) {
                  f = targetFiles[i];
                  d.push(f);
                }
                return cb();
              });
            };
          };
        })(this));
        return async.series(x, function() {
          return callback(null, d);
        });
      }
    };

    NinjaStar.prototype.single = function(command, pattern, dest, callback) {
      return this.findTargets(pattern, (function(_this) {
        return function(err, files) {
          var f, i, len;
          for (i = 0, len = files.length; i < len; i++) {
            f = files[i];
            _this.registerSingle(f, command, dest);
          }
          return callback();
        };
      })(this));
    };

    NinjaStar.prototype.aggregate = function(command, pattern, dest, callback) {
      return this.findTargets(pattern, (function(_this) {
        return function(err, files) {
          _this.registerAggregate(files, command, dest);
          return callback();
        };
      })(this));
    };

    NinjaStar.prototype.linePattern = function(name) {
      var p;
      p = {
        single: this.single,
        aggregate: this.aggregate
      };
      return p[name];
    };

    NinjaStar.prototype.generateNinja = function(callback) {
      var conf, mapping, name, ref, rule;
      this.ninja = ninjaBulidGen(null, 'build');
      this.memoryTargets = [];
      ref = this.rules;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        conf = ref[name];
        rule = this.ninja.rule(name);
        rule.run(conf.command);
        if (conf.description) {
          rule.description(conf.description);
        }
      }
      mapping = this.buildLines.map((function(_this) {
        return function(buildline) {
          return function(callback) {
            var args, fn, ruleName, type;
            ruleName = buildline[0];
            type = _this.rules[ruleName].type || 'single';
            fn = _this.linePattern(type);
            args = buildline.concat([callback]);
            return fn.apply(null, args);
          };
        };
      })(this));
      return async.series(mapping, (function(_this) {
        return function(err, results) {
          return _this.ninja.save('build.ninja', function() {
            return callback();
          });
        };
      })(this));
    };

    return NinjaStar;

  })();

  module.exports = NinjaStar;

}).call(this);
